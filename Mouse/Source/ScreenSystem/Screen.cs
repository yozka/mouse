using System;
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Input;
using Microsoft.Xna.Framework.Input.Touch;
using Microsoft.Xna.Framework.Content;

namespace Mouse.ScreenSystem
{


    ///=====================================================================================
    ///
    /// <summary>
    /// Тип экранов, используется для индендификации типа контента на экране
    /// </summary>
    /// 
    ///--------------------------------------------------------------------------------------
    public enum EScreenContent
    {
        None,
        Logo,

        /// <summary>
        /// Главное меню
        /// </summary>
        Menu,

        /// <summary>
        /// Задний фон меню
        /// </summary>
        MenuBackground,

        /// <summary>
        /// Игровой цыкл
        /// </summary>
        Game,

        /// <summary>
        /// Завершение игры
        /// </summary>
        GameOver,

        /// <summary>
        /// Меню паузы
        /// </summary>
        Pause,

        /// <summary>
        /// Экран настройки акселерометра
        /// </summary>
        Acceleration,

        /// <summary>
        /// Меню настройки игры
        /// </summary>
        Options


    }
    ///--------------------------------------------------------------------------------------






    ///=====================================================================================
    ///
    /// <summary>
    /// Описываеем состояния перехода экрана.
    /// </summary>
    /// 
    ///--------------------------------------------------------------------------------------
    public enum EScreenState
    {
        TransitionOn,
        Active,
        TransitionOff,
        Hidden
    }
    ///--------------------------------------------------------------------------------------






    ///=====================================================================================
    ///
    /// <summary>
    /// Эффект закрытия экрана.
    /// </summary>
    /// 
    ///--------------------------------------------------------------------------------------
    public enum EHidenState
    {
        Alpha,
        Rotation
    }
    ///--------------------------------------------------------------------------------------







     ///=====================================================================================
    ///
    /// <summary>
    /// Базовый экран, предсавляющий один слой, который может отрисовыватся и 
    /// делать логические штуки.
    /// Может быть объединен с другими слоями для создания комплексной системы меню.
    /// Например, в главном меню, пункты меню, "Вы уверены?",
    /// Также эти экраны можно использовать как диалоговые окна, 
    /// Причем вся игра реализованна
    /// на экранах.
    /// </summary>
    /// 
    ///--------------------------------------------------------------------------------------
    public abstract class AScreen
    {
        private bool            m_initialized = false;//признак инциализации экрана
        private bool            m_firstRun = true;
        private GestureType     m_enabledGestures = GestureType.None;
        private bool            m_isExiting = false;
        private bool            m_otherScreenHasFocus = false;
        private EScreenState    m_screenState = EScreenState.TransitionOn;
        private EHidenState     m_hidenState = EHidenState.Alpha;
        private TimeSpan        m_transitionOffTime = TimeSpan.Zero;
        private TimeSpan        m_transitionOnTime = TimeSpan.Zero;
        private float           m_transitionPosition = 1;


        private ContentManager  m_contentManager = null;
        private bool            m_loadContent = false;//признак того что контент уже загружался
        ///--------------------------------------------------------------------------------------







         ///=====================================================================================
        ///
        /// <summary>
        /// Заголовок экрана, используется в меню
        /// </summary>
        /// 
        ///--------------------------------------------------------------------------------------
        public virtual string getCaption()
        {
            return ToString();
        }
        ///--------------------------------------------------------------------------------------








         ///=====================================================================================
        ///
        /// <summary>
        /// Определяется тип, группа экрана.
        /// Также показывается что обрабатывает экран
        /// </summary>
        /// 
        ///--------------------------------------------------------------------------------------
        public virtual EScreenContent getTypeContent()
        {
            return EScreenContent.None;
        }
        ///--------------------------------------------------------------------------------------








         ///=====================================================================================
        ///
        /// <summary>
        /// Установка значений на первый запуск.
        /// Также идет определение, добавлен этот экран в менеджер или нет
        /// </summary>
        /// 
        ///--------------------------------------------------------------------------------------
        public bool firstRun
        {
            get { return m_firstRun; }
            set { m_firstRun = value; }
        }
        ///--------------------------------------------------------------------------------------






        ///=====================================================================================
        ///
        /// <summary>
        /// Указывается что этот экран является всплывающим.
        /// Если это всплывающие окно, то флаг в апдейт coveredByOtherScreen будет false 
        /// Когда есть всплывающие окно, то все остальные окна, отрисовываются, и не исчезают
        /// </summary>
        /// 
        ///--------------------------------------------------------------------------------------
        public bool isPopup { get; protected set; }
        ///--------------------------------------------------------------------------------------






        ///=====================================================================================
        ///
        /// <summary>
        /// Указывает, сколько требуется, чтобы был завершен переход экрана
        /// из состояния который показывает экран
        /// </summary>
        /// 
        ///--------------------------------------------------------------------------------------
        public TimeSpan transitionOnTime
        {
            get { return m_transitionOnTime; }
            protected set { m_transitionOnTime = value; }
        }
        ///--------------------------------------------------------------------------------------






        ///=====================================================================================
        ///
        /// <summary>
        /// Указывает, сколько требуется, чтобы был завершен переход экрана
        /// из состояния который СКРЫВАЕТ экран
        /// </summary>
        /// 
        ///--------------------------------------------------------------------------------------
        public TimeSpan transitionOffTime
        {
            get { return m_transitionOffTime; }
            protected set { m_transitionOffTime = value; }
        }
        ///--------------------------------------------------------------------------------------






        ///=====================================================================================
        ///
        /// <summary>
        /// Возвращает текущую позицию на экране перехода, начиная
        /// от нуля (полностью активная, не переход) к 1 (перешли
        /// полностью, выключен).
        /// </summary>
        /// 
        ///--------------------------------------------------------------------------------------
        public float transitionPosition
        {
            get { return m_transitionPosition; }
            protected set { m_transitionPosition = value; }
        }
        ///--------------------------------------------------------------------------------------






        ///=====================================================================================
        ///
        /// <summary>
        /// Возвращает текущий переход альфа-экрана, начиная
        /// От 1 (полностью активная, не переход) до 0 (перешли
        /// полностью выключен, ничего).
        /// </summary>
        /// 
        ///--------------------------------------------------------------------------------------
        public float transitionAlpha
        {
            get { return 1f - transitionPosition; }
        }
        ///--------------------------------------------------------------------------------------






         ///=====================================================================================
        ///
        /// <summary>
        /// Получает текущее состояние экрана.
        /// </summary>
        /// 
        ///--------------------------------------------------------------------------------------
        public EScreenState screenState
        {
            get { return m_screenState; }
            protected set { m_screenState = value; }
        }
        ///--------------------------------------------------------------------------------------







        ///=====================================================================================
        ///
        /// <summary>
        /// Установка эффекта закрытия окна.
        /// </summary>
        /// 
        ///--------------------------------------------------------------------------------------
        public EHidenState hidenState
        {
            get { return m_hidenState; }
            protected set { m_hidenState = value; }
        }
        ///--------------------------------------------------------------------------------------







        ///=====================================================================================
        ///
        /// <summary>
        /// Есть две возможные причины, почему экран может быть переход на выключение
        /// Это может быть что экран временно исчезнуть, чтобы освободить место для другого нового popup экрана,
        /// который находится на вершине стека, или он может быть удаляется навсегда.
        /// Это свойство указывает, является ли экран действительно на удалении.
        /// Если он установлен, то экран автоматический удалит себя, как только будет завершенно
        /// переход трансформации на исчезновение экрана
        /// </summary>
        /// 
        /// -------------------------------------------------------------------------------------
        /// 
        public bool isExiting
        {
            get { return m_isExiting; }
            protected internal set { m_isExiting = value; }
        }
        ///--------------------------------------------------------------------------------------







        ///=====================================================================================
        ///
        /// <summary>
        /// Проверка, является ли экран активным, и он принимает сигналы с переферии воода информации
        /// </summary>
        /// 
        ///--------------------------------------------------------------------------------------
        public bool isActive
        {
            get
            {
                return !m_otherScreenHasFocus &&
                       (m_screenState == EScreenState.TransitionOn ||
                        m_screenState == EScreenState.Active);
            }
        }
        ///--------------------------------------------------------------------------------------







        ///=====================================================================================
        ///
        /// <summary>
        /// ВОзвращаем менеджера экрана, кому экран принадлежит.
        /// (это свйоство инцилизирует менеджер экранов)
        /// </summary>
        /// 
        ///--------------------------------------------------------------------------------------
        public AScreenManager screenManager { get; internal set; }
        ///--------------------------------------------------------------------------------------







        ///=====================================================================================
        ///
        /// <summary>
        /// Включение перехвата обработки жестов, конкретно для данного экрана
        /// Эти жесты обрабатываются ScreenManager когда экраны изменится и
        /// все жесты находятся в InputState передается методу handleInput.
        /// </summary>
        /// 
        ///--------------------------------------------------------------------------------------
        public GestureType enabledGestures
        {
            get { return m_enabledGestures; }
            protected set
            {
                m_enabledGestures = value;

                //перехват жестов, можно установить только на активный экран
                if (screenState == EScreenState.Active)
                {
                    TouchPanel.EnabledGestures = value;
                }
            }
        }
        ///--------------------------------------------------------------------------------------





         ///=====================================================================================
        ///
        /// <summary>
        /// возвратим контент
        /// </summary>
        /// 
        ///--------------------------------------------------------------------------------------
        public ContentManager content
        {
            get
            {
                return m_contentManager;
            }
        }
        ///--------------------------------------------------------------------------------------






         ///=====================================================================================
        ///
        /// <summary>
        /// признак загруженности контента
        /// </summary>
        /// 
        ///--------------------------------------------------------------------------------------
        public bool isContent
        {
            get
            {
                return m_loadContent;
            }
        }
        ///--------------------------------------------------------------------------------------







         ///=====================================================================================
        ///
        /// <summary>
        /// Начало загрузки графического контента экрана
        /// </summary>
        /// 
        ///--------------------------------------------------------------------------------------
        public void loadContent()
        {
            if (!m_loadContent)
            {
                m_contentManager = new ContentManager(screenManager.Game.Content.ServiceProvider, "Content");
                onLoadContent(m_contentManager);
                m_loadContent = true;
            }
        }
        ///--------------------------------------------------------------------------------------








         ///=====================================================================================
        ///
        /// <summary>
        /// Виртуальный метод загрузки графического контента игры
        /// </summary>
        /// 
        ///--------------------------------------------------------------------------------------
        protected virtual void onLoadContent(ContentManager content)
        {
        }
        ///--------------------------------------------------------------------------------------








         ///=====================================================================================
        ///
        /// <summary>
        /// Выгрузка графического контента
        /// </summary>
        /// 
        ///--------------------------------------------------------------------------------------
        public void unloadContent()
        {
            if (m_loadContent)
            {
                m_loadContent = false;
                onUnloadContent();
                m_contentManager.Unload();
                m_contentManager.Dispose();
            }
        }
        ///--------------------------------------------------------------------------------------








         ///=====================================================================================
        ///
        /// <summary>
        /// Виртуальный метод выгрузки графического контента игры
        /// </summary>
        /// 
        ///--------------------------------------------------------------------------------------
        protected virtual void onUnloadContent()
        {
        }
        ///--------------------------------------------------------------------------------------




        

         ///=====================================================================================
        ///
        /// <summary>
        /// Инциализация экрана
        /// </summary>
        /// 
        ///--------------------------------------------------------------------------------------
        public void initialized()
        {
            if (!m_initialized)
            {
                m_initialized = true;
                onInitialized();
            }
        }
        ///--------------------------------------------------------------------------------------







         ///=====================================================================================
        ///
        /// <summary>
        /// Виртуальный метод инциализации экрана, выполняется только один раз
        /// </summary>
        /// 
        ///--------------------------------------------------------------------------------------
        protected virtual void onInitialized()
        {
        }
        ///--------------------------------------------------------------------------------------




        



         ///=====================================================================================
        ///
        /// <summary>
        /// Идет запуск внутренней логики экрана, такое как обновление переход положение.
        /// В отличие от handleInput, этот метод вызвывается независимо от того,
        /// активен ли экран, или находится ли он на переходе.
        /// Пользоватся этим методом нужно осторожно, ибо он вызывается всегда.
        /// </summary>
        /// <param name="otherScreenHasFocus">
        /// Состояние фокуса.
        /// true - фокус имеется на другом экране, 
        /// false - фокус находится на текущем экране
        /// </param>
        /// <param name="coveredByOtherScreen">
        /// Признак того что еще монитор устройства не захвачен другим экраном
        /// true - монитор захвачен другим экранам и текущий экран нужно скрыть.
        /// false - монитор полностью свободет, этот экран находится на вершине стека
        /// </param>
        /// 
        ///--------------------------------------------------------------------------------------
        public virtual void onUpdate( TimeSpan gameTime, 
                                    bool otherScreenHasFocus,
                                    bool coveredByOtherScreen)
        {
            m_otherScreenHasFocus = otherScreenHasFocus;

            if (m_isExiting)
            {
                //этот экран ждет удаления из менеджера экранов
                m_screenState = EScreenState.TransitionOff;

                if (!updateTransition(gameTime, m_transitionOffTime, 1))
                {
                    //ага, экран полностью скрылся с места, теперь его можно удалить из менеджера экранов
                    screenManager.removeScreen(this);
                }
            }
            else if (coveredByOtherScreen)
            {
                // Если экран перекрывает другим popup экраном, то мы должны свернутся
                if (updateTransition(gameTime, m_transitionOffTime, 1))
                {
                    // да, мы еще сварачиваемся
                    m_screenState = EScreenState.TransitionOff;
                }
                else
                {
                    // Переход завершен, скроем экран
                    m_screenState = EScreenState.Hidden;
                }
            }
            else
            {
                // В противном случае, мы на вершине стека экранов и должны показатся и стать активным.
                if (updateTransition(gameTime, m_transitionOnTime, -1))
                {
                    // Ждем, еще пка не перешли
                    m_screenState = EScreenState.TransitionOn;
                }
                else
                {
                    // Полностью перешли экран
                    m_screenState = EScreenState.Active;
                }
            }
        }
        ///--------------------------------------------------------------------------------------







        ///=====================================================================================
        ///
        /// <summary>
        /// Вспомогательный метод по обновлению положение экрана перехода.
        /// </summary>
        /// 
        ///--------------------------------------------------------------------------------------
        private bool updateTransition(TimeSpan gameTime, TimeSpan time, int direction)
        {
            float transitionDelta;

            if (time == TimeSpan.Zero)
                transitionDelta = 1;
            else
                transitionDelta = (float)(gameTime.TotalMilliseconds /
                                           time.TotalMilliseconds);

            // обновляем текущую позицию
            m_transitionPosition += transitionDelta * direction;

            // проверка, на выполнение полностю перехода
            if (((direction < 0) && (m_transitionPosition <= 0)) ||
                ((direction > 0) && (m_transitionPosition >= 1)))
            {
                m_transitionPosition = MathHelper.Clamp(m_transitionPosition, 0, 1);
                return false;
            }

            // переход еще не завершен
            return true;
        }
        ///--------------------------------------------------------------------------------------







        ///=====================================================================================
        ///
        /// <summary>
        /// Метод обрабатывает пользовательский ввод. В отличие от обновления, этот метод
        /// вызывается только когда экран активен, а не тогда, когда другие
        /// экран перехватили фокус.
        /// </summary>
        /// 
        ///--------------------------------------------------------------------------------------
        public virtual void onHandleInput(AInputHelper input)
        {

        }
        ///--------------------------------------------------------------------------------------







         ///=====================================================================================
        ///
        /// <summary>
        /// Отрисовка экрана
        /// </summary>
        /// 
        ///--------------------------------------------------------------------------------------
        public virtual void onDraw(TimeSpan gameTime)
        {
        }
        ///--------------------------------------------------------------------------------------







         ///=====================================================================================
        ///
        /// <summary>
        /// закрытие экрана, и полностью его удаление
        /// </summary>
        /// 
        ///--------------------------------------------------------------------------------------
        public void exitScreen()
        {
            if (transitionOffTime == TimeSpan.Zero)
            {
                screenManager.removeScreen(this);
            }
            else
            {
                m_isExiting = true;
            }
        }
        ///--------------------------------------------------------------------------------------







         ///=====================================================================================
        ///
        /// <summary>
        /// активация фокуса у экрана
        /// </summary>
        /// 
        ///--------------------------------------------------------------------------------------
        public virtual void onFocusActivation(AScreen focus)
        {
        }
        ///--------------------------------------------------------------------------------------






         ///=====================================================================================
        ///
        /// <summary>
        /// Снятие фокуса у экрана
        /// </summary>
        /// 
        ///--------------------------------------------------------------------------------------
        public virtual void onFocusDeactivation(AScreen focus)
        {

        }




    }//AGameScreen
}
